<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinity Castle Survival - Tanjiro & Giyu</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Pretendard', sans-serif; background: #0c0805; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            padding: 20px; box-sizing: border-box;
        }
        .top-ui { display: flex; justify-content: space-between; align-items: flex-start; }
        .stats {
            background: rgba(20, 10, 5, 0.85); padding: 15px; border-radius: 8px;
            border-left: 4px solid #00f2fe; color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .hp-container { width: 250px; height: 12px; background: #221a15; border-radius: 6px; margin-top: 8px; overflow: hidden; border: 1px solid #443322; }
        #player-hp { width: 100%; height: 100%; background: linear-gradient(90deg, #00d2ff, #3a7bd5); transition: width 0.3s; }
        .kill-count { font-size: 28px; font-weight: bold; color: #ff3311; text-shadow: 0 0 15px rgba(255, 50, 0, 0.8); }
        #message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 50px; font-weight: 900; display: none; text-shadow: 0 0 30px #ff0000;
            background: rgba(0,0,0,0.5); padding: 20px 40px; border-radius: 10px;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top-ui">
        <div class="stats">
            <div style="font-weight: bold; font-size: 18px;">LEVEL <span id="level-val">1</span> | 탄지로 & 기유</div>
            <div class="hp-container"><div id="player-hp"></div></div>
            <div style="margin-top:8px; font-size:11px; color:#cba;">[WASD] 이동 [J] 베기 [K] 물의 호흡</div>
        </div>
        <div class="kill-count">KILLS: <span id="kill-val">0</span></div>
    </div>
    <div id="message"></div>
</div>

<script>
    const config = {
        maxEnemies: 15,
        spawnInterval: 1200,
        playerSpeed: 9,
        attackRange: 4,
        damage: 45
    };

    const gameState = {
        playerHP: 100,
        maxHP: 100,
        kills: 0,
        isGameOver: false,
        lastAttack: 0
    };

    let scene, camera, renderer, clock;
    let player, giyu, enemies = [], particles = [], crows = [], npcs = [];
    const keys = {};

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0c0805); 
        scene.fog = new THREE.Fog(0x0c0805, 20, 80);

        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        const ambient = new THREE.AmbientLight(0xffeebb, 0.5);
        scene.add(ambient);
        
        const mainLight = new THREE.PointLight(0xffaa44, 1.5, 150);
        mainLight.position.set(0, 30, 0);
        mainLight.castShadow = true;
        scene.add(mainLight);

        // 무한성 스타일 바닥 (격자 무늬 캔버스 텍스처)
        const groundSize = 150;
        const groundCanvas = document.createElement('canvas');
        groundCanvas.width = 256; groundCanvas.height = 256;
        const gctx = groundCanvas.getContext('2d');
        gctx.fillStyle = '#2d1b0f'; gctx.fillRect(0,0,256,256);
        gctx.strokeStyle = '#1a0f0a'; gctx.lineWidth = 4;
        for(let i=0; i<4; i++) for(let j=0; j<4; j++) gctx.strokeRect(i*64, j*64, 64, 64);
        const groundTex = new THREE.CanvasTexture(groundCanvas);
        groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
        groundTex.repeat.set(20, 20);

        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshPhongMaterial({ map: groundTex });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 무한성 벽 구조물 및 연결된 다리 생성
        createInfinityCastleEnvironment();

        // 캐릭터 생성
        createTanjiro();
        createGiyu();

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('keydown', handleInput);
        window.addEventListener('resize', onWindowResize);

        for(let i=0; i<6; i++) spawnCrow();

        animate();
        setInterval(spawnEnemy, config.spawnInterval);
    }

    function createInfinityCastleEnvironment() {
        const wallDist = 50;
        // 양쪽 거대한 벽면 (무한성 느낌)
        const wallGeo = new THREE.BoxGeometry(2, 100, 150);
        const wallMat = new THREE.MeshPhongMaterial({ color: 0x1a0f0a });
        
        const leftWall = new THREE.Mesh(wallGeo, wallMat);
        leftWall.position.set(-wallDist, 20, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(wallGeo, wallMat);
        rightWall.position.set(wallDist, 20, 0);
        scene.add(rightWall);

        // 벽에 연결된 다리들
        for (let i = 0; i < 12; i++) {
            const h = 5 + Math.random() * 30;
            const length = 20 + Math.random() * 20;
            const bridgeGeo = new THREE.BoxGeometry(length, 0.8, 4);
            const bridgeMat = new THREE.MeshPhongMaterial({ color: 0x2d1b0f });
            const bridge = new THREE.Mesh(bridgeGeo, bridgeMat);
            
            const side = Math.random() > 0.5 ? 1 : -1;
            bridge.position.set((wallDist - length/2) * side, h, (Math.random()-0.5) * 80);
            scene.add(bridge);

            // 다리 위 걷는 NPC
            const npc = createGenericSlayer();
            npc.position.set(bridge.position.x, bridge.position.y + 1.2, bridge.position.z);
            npc.walkRange = length * 0.4;
            npc.baseX = bridge.position.x;
            npcs.push(npc);
            scene.add(npc);
        }
    }

    function createGenericSlayer() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), new THREE.MeshPhongMaterial({color: 0x111111}));
        group.add(body);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshPhongMaterial({color: 0xffdbac}));
        head.position.y = 0.8;
        group.add(head);
        return group;
    }

    function createTanjiro() {
        player = new THREE.Group();
        
        // 체크무늬 하오리
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#004d40'; ctx.fillRect(0,0,64,64);
        ctx.fillStyle = '#000'; 
        for(let i=0; i<4; i++) for(let j=0; j<4; j++) if((i+j)%2===0) ctx.fillRect(i*16, j*16, 16, 16);
        const texture = new THREE.CanvasTexture(canvas);
        
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.5), new THREE.MeshPhongMaterial({map: texture}));
        player.add(body);
        
        const headGroup = new THREE.Group();
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.5), new THREE.MeshPhongMaterial({color: 0xffdbac}));
        headGroup.add(head);

        const hairMat = new THREE.MeshPhongMaterial({color: 0x3d1a11});
        const hairBase = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.35, 0.6), hairMat);
        hairBase.position.y = 0.25;
        headGroup.add(hairBase);

        for(let i=0; i<8; i++) {
            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 4), hairMat);
            spike.position.set((Math.random()-0.5)*0.6, 0.3, (Math.random()-0.5)*0.5);
            spike.rotation.x = Math.random();
            headGroup.add(spike);
        }

        headGroup.position.y = 1;
        player.add(headGroup);

        player.sword = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.8, 0.1), new THREE.MeshPhongMaterial({color: 0x111111}));
        player.sword.position.set(0.6, 0, 0.4);
        player.sword.rotation.x = Math.PI/4;
        player.add(player.sword);

        scene.add(player);
    }

    function createGiyu() {
        giyu = new THREE.Group();
        
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#9e1a1a'; ctx.fillRect(0,0,32,64);
        ctx.fillStyle = '#fdd835'; ctx.fillRect(32,0,32,64); 
        ctx.strokeStyle = '#e65100'; ctx.lineWidth = 1;
        for(let i=32; i<64; i+=8) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,64); ctx.stroke(); }

        const texture = new THREE.CanvasTexture(canvas);
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.5), new THREE.MeshPhongMaterial({map: texture}));
        giyu.add(body);
        
        const headGroup = new THREE.Group();
        // 차가운 인상을 위한 눈매 표현 생략 (기본 헤드 색상 사용하되 형태만 날카롭게)
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.5), new THREE.MeshPhongMaterial({color: 0xffdbcc}));
        headGroup.add(head);

        // 기유 머리카락 (길고 삐죽삐죽함)
        const hairMat = new THREE.MeshPhongMaterial({color: 0x050505});
        const hairBase = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.4, 0.65), hairMat);
        hairBase.position.y = 0.25;
        headGroup.add(hairBase);

        // 더 많고 긴 스파이크 추가
        for(let i=0; i<12; i++) {
            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.6, 4), hairMat);
            spike.position.set((Math.random()-0.5)*0.7, 0.2, (Math.random()-0.5)*0.6);
            spike.rotation.set(Math.random()*2, Math.random()*2, Math.random()*2);
            headGroup.add(spike);
        }
        // 뒷머리 특징
        const ponytail = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.8, 4), hairMat);
        ponytail.position.set(0, -0.2, -0.4);
        ponytail.rotation.x = -Math.PI/3;
        headGroup.add(ponytail);

        headGroup.position.y = 1;
        giyu.add(headGroup);

        giyu.position.set(-3, 0.7, 0);
        scene.add(giyu);
    }

    function spawnCrow() {
        const crow = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.8), new THREE.MeshBasicMaterial({color: 0x000000}));
        crow.add(body);
        const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.4), new THREE.MeshBasicMaterial({color: 0x0a0a0a}));
        wingL.position.x = -0.5;
        crow.add(wingL);
        const wingR = wingL.clone();
        wingR.position.x = 0.5;
        crow.add(wingR);
        
        crow.position.set((Math.random()-0.5)*80, 20 + Math.random()*10, (Math.random()-0.5)*80);
        crow.wingL = wingL; crow.wingR = wingR;
        scene.add(crow);
        crows.push(crow);
    }

    function spawnEnemy() {
        if (gameState.isGameOver || enemies.length >= config.maxEnemies) return;
        const enemy = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.5), new THREE.MeshPhongMaterial({color: 0x212121}));
        enemy.add(body);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshPhongMaterial({color: 0x666666}));
        head.position.y = 0.9;
        enemy.add(head);

        const angle = Math.random() * Math.PI * 2;
        const dist = 25;
        enemy.position.set(player.position.x + Math.cos(angle)*dist, 0.7, player.position.z + Math.sin(angle)*dist);
        enemy.hp = 80;
        scene.add(enemy);
        enemies.push(enemy);
    }

    function handleInput(e) {
        if (e.code === 'KeyJ') attack('slash');
        if (e.code === 'KeyK') attack('water');
    }

    function attack(type) {
        if (Date.now() - gameState.lastAttack < 300) return;
        gameState.lastAttack = Date.now();

        const isWater = type === 'water';
        const range = isWater ? 8 : 4.5;
        const dmg = isWater ? 80 : 40;
        const color = isWater ? 0x00ffff : 0xffffff;

        createEffect(player.position, color, isWater ? 6 : 2.5);
        if(isWater) createEffect(giyu.position, 0x1e88e5, 4);

        enemies.forEach((e, i) => {
            if (player.position.distanceTo(e.position) < range) {
                e.hp -= dmg;
                const dir = new THREE.Vector3().subVectors(e.position, player.position).normalize();
                e.position.addScaledVector(dir, 2.5);
                if (e.hp <= 0) {
                    scene.remove(e);
                    enemies.splice(i, 1);
                    gameState.kills++;
                }
            }
        });
    }

    function createEffect(pos, color, size) {
        const geo = new THREE.TorusGeometry(size, 0.15, 12, 40);
        const mat = new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.7});
        const ring = new THREE.Mesh(geo, mat);
        ring.rotation.x = Math.PI/2;
        ring.position.copy(pos);
        scene.add(ring);
        particles.push({mesh: ring, life: 1.0});
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (!gameState.isGameOver) {
            // 탄지로 컨트롤
            const moveDir = new THREE.Vector3();
            if (keys['KeyW']) moveDir.z -= 1;
            if (keys['KeyS']) moveDir.z += 1;
            if (keys['KeyA']) moveDir.x -= 1;
            if (keys['KeyD']) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize();
                player.position.addScaledVector(moveDir, config.playerSpeed * delta);
                player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, Math.atan2(moveDir.x, moveDir.z), 0.15);
            }

            // 기유 AI 동행
            const followPos = player.position.clone().add(new THREE.Vector3(-3.5, 0, 1.5));
            giyu.position.lerp(followPos, 0.08);
            giyu.lookAt(player.position.x + 10, 0.7, player.position.z);

            // 적 AI
            enemies.forEach(e => {
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                e.position.addScaledVector(dir, 4 * delta);
                e.lookAt(player.position);
                if (player.position.distanceTo(e.position) < 1.4) gameState.playerHP -= 0.2;
            });

            // 까마귀 비행
            crows.forEach(c => {
                c.position.z -= 0.2;
                c.wingL.rotation.z = Math.sin(Date.now()*0.015) * 0.6;
                c.wingR.rotation.z = -Math.sin(Date.now()*0.015) * 0.6;
                if (c.position.z < -60) c.position.z = 60;
            });

            // NPC 다리 위 순찰
            npcs.forEach(n => {
                n.position.x = n.baseX + Math.sin(Date.now()*0.001) * n.walkRange;
            });

            // 카메라 연출
            const camTarget = new THREE.Vector3(player.position.x, 22, player.position.z + 22);
            camera.position.lerp(camTarget, 0.06);
            camera.lookAt(player.position.x, 0, player.position.z);

            if (gameState.playerHP <= 0) {
                gameState.isGameOver = true;
                document.getElementById('message').style.display = 'block';
                document.getElementById('message').innerText = "임무 실패";
            }
        }

        // 파티클
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= delta * 1.5;
            p.mesh.scale.multiplyScalar(1.05);
            p.mesh.material.opacity = Math.max(0, p.life);
            if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
        }

        document.getElementById('player-hp').style.width = Math.max(0, gameState.playerHP) + '%';
        document.getElementById('kill-val').innerText = gameState.kills;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.onload = init;
</script>
</body>
</html>